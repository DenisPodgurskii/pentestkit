const optionsRegex = /(--[a-zA-Z\-]+ '.*?')|(--[a-zA-Z\-]+)|(-[a-zA-Z\-]+? '[\s\S]*?')|('?[a-z]+:\/\/.*?'+?)|("?[a-z]+:\/\/.*?"+?)/g; // eslint-disable-line
const urlRegex = /^((http|https):\/\/){1}(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9])\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9\-]*[A-Za-z0-9])?(:+[0-9]+)?([\/\?]{1}.*)?$/i // eslint-disable-line

const contentTypeHeader = 'content-type';
const jsonMimeType = 'application/json';

const isMatchingOption = (headers, str) => {
  for (let i = 0; i < headers.length; i += 1) {
    if (str.startsWith(headers[i])) {
      return true;
    }
  }
  return false;
};

const isMethodOption = str => isMatchingOption(['-X ', '--request '], str);
const isAHeaderOption = str => isMatchingOption(['-H ', '--headers '], str);
const isDataOption = str => isMatchingOption(['--data ', '--data-ascii ', '-d ', '--data-raw ', '--dta-urlencode ', '--data-binary '], str);

const removeLeadingTrailingQuotes = (str) => {
  const quotes = ['\'', '"'];
  let newStr = str.trim();
  if (newStr.startsWith("'") || newStr.startsWith('"')) newStr = newStr.substr(1)
  if (newStr.endsWith("'") || newStr.endsWith('"')) newStr = newStr.substr(0, newStr.length - 1)
  return quotes.includes(newStr[0]) ? newStr.substr(1, newStr.length - 2) : newStr;
};

const subStrFrom = (val, startFromVal) => {
  const dataPosition = val.indexOf(startFromVal);
  return val.substr(dataPosition);
};

const isJsonRequest = headers => (headers[contentTypeHeader] &&
  headers[contentTypeHeader].indexOf(jsonMimeType) !== -1);

const parseBodyByContentType = ({ body, headers }) => {
  if (body && isJsonRequest(headers)) {
    try {
      const cleanedBodyData = body.replace('\\"', '"').replace("\\'", "'");
      return JSON.parse(cleanedBodyData);
    } catch (ex) {
      // ignore json conversion error..
      console.log('Cannot parse JSON Data ' + ex.message); // eslint-disable-line
    }
  }
  return body;
};

const parseOptionValue = (val) => {
  const headerSplit = subStrFrom(val, ' ').split(':');
  return {
    key: headerSplit[0].trim(),
    value: headerSplit[1].trim(),
  };
};

const parseMethod = (val) => {
  const strArr = subStrFrom(val, ' ');
  return strArr.trim().replace("'", "").replace('"', '')
};

const parseQueryStrings = (url) => {
  const paramPosition = url.indexOf('?');
  const queryStrings = {};
  if (paramPosition !== -1) {
    // const splitUrl = parsedCommand.url.substr(0, paramPosition);
    const paramsString = url.substr(paramPosition + 1);
    const params = paramsString.split('&') || [];

    params.forEach((param) => {
      const splitParam = param.split('='); // eslint-disable-line
      queryStrings[splitParam[0]] = splitParam[1]; // eslint-disable-line
    });
  }
  return queryStrings;
};

const parseUrlOption = (val) => {
  const urlMatches = val.match(urlRegex) || [];
  if (urlMatches.length) {
    const url = urlMatches[0]; // eslint-disable-line
    return {
      url,
      queryStrings: parseQueryStrings(url),
    };
  }
  return { url: '', queryStrings: {} };
};

const parseBody = val => removeLeadingTrailingQuotes(subStrFrom(val, ' '));

const isACurlCommand = val => val.trim().startsWith('curl ');
const isAUrlOption = (val) => {
  const matches = val.match(urlRegex) || [];
  return !!matches.length;
};

/*
 * Parse cUrl command to a JSON structure
 * params:
 * command - cUrl command as a string.
 * return JSON object
*/
export function parse(command) {
  if (!command) { return ''; }

  const parsedCommand = {
    url: '',
  };

  // quit if the command does not starts with curl
  if (isACurlCommand(command)) {
    const matches = command.match(optionsRegex);
    matches.forEach((val) => {
      const option = removeLeadingTrailingQuotes(val);
      if (isAUrlOption(option)) {
        const { url, queryStrings } = parseUrlOption(option);
        parsedCommand.url = url;
        parsedCommand.queryStrings = queryStrings;
      } else if (isAHeaderOption(option)) {
        const { key, value } = parseOptionValue(option);
        parsedCommand.headers = parsedCommand.headers || {};
        parsedCommand.headers[removeLeadingTrailingQuotes(key).toLowerCase()] = removeLeadingTrailingQuotes(value).toLowerCase();
      } else if (isDataOption(option)) {
        parsedCommand.body = parseBody(option);
      } else if (isMethodOption(option)) {
        parsedCommand.method = parseMethod(option);
      } else {
        console.log(`Skipped Header ${val}`); // eslint-disable-line
      }
    }); // parse over matches ends

    // should be checked after all the options are analyzed
    // so that we guarentee that we have content-type header
    parsedCommand.body = parseBodyByContentType(parsedCommand);
  }

  return parsedCommand;
}

export default parse;

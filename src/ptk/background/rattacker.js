/* Author: Denis Podgurskii */
import { ptk_sqlinjection } from "../modules/active/sqlinjection.js"
import { ptk_xss } from "../modules/active/xss.js"
import { ptk_oscommand } from "../modules/active/oscommand.js"
import { ptk_jwt } from "../modules/active/jwt.js"
import { ptk_request } from "../background/request.js"
import { ptk_iast } from "../background/iast.js"
import { ptk_utils, ptk_logger, ptk_queue, ptk_storage } from "../background/utils.js"

const worker = self

export class ptk_rattacker {

    constructor(settings) {
        this.settings = settings
        this.storageKey = "ptk_rattacker"
        this.resetScanResult()
        this.attackModules = {
            SqlInjection: new ptk_sqlinjection(),
            XSS: new ptk_xss(),
            OSCommand: new ptk_oscommand(),
            JWT: new ptk_jwt()
        }
    }

    async init() {
        this.storage = await ptk_storage.getItem(this.storageKey)
        if (Object.keys(this.storage).length > 0) {
            this.scanResult = this.storage
            this.scanResult.uniqueRequestQueue = new ptk_queue(this.scanResult.uniqueRequestQueue.items)
            this.scanResult.requestQueue = new ptk_queue(this.scanResult.requestQueue.items)
        }
    }

    resetScanResult(){
        this.scanResult = {
            scannedTabId: null,
            scanId: null,
            tabId: null,
            host: null,
            uniqueRequestQueue: new ptk_queue(),
            requestQueue: new ptk_queue(),
            items: {},
            stats: {
                vulnsCount: 0,
                attacksCount: 0
            },
            settings: {}
        }
    }

    async reset() {
        ptk_storage.setItem(this.storageKey, {})
        this.resetScanResult()
    }

    addMessageListeners() {
        this.onMessage = this.onMessage.bind(this)
        browser.runtime.onMessage.addListener(this.onMessage)
    }

    addListeners() {
        this.onRemoved = this.onRemoved.bind(this)
        browser.tabs.onRemoved.addListener(this.onRemoved)

        this.onCompleted = this.onCompleted.bind(this)
        browser.webRequest.onCompleted.addListener(
            this.onCompleted,
            { urls: ["<all_urls>"], types: ptk_utils.requestFilters },
            ["responseHeaders"].concat(ptk_utils.extraInfoSpec)
        )
    }

    removeListeners() {
        browser.tabs.onRemoved.removeListener(this.onRemoved)
        browser.webRequest.onCompleted.removeListener(this.onCompleted)
    }

    onRemoved(tabId, info) {
        if (this.scanResult?.tabId == tabId) this.scanResult.tabId = null
    }

    onCompleted(response) {
        if (this.scanResult?.tabId == response.tabId && !this.settings.blacklist.includes(response.type)) {
            let r = worker.ptk_app.proxy.getRawRequest(worker.ptk_app.proxy.getTab(response.tabId), response.frameId, response.requestId)
            this.addRequest(r)
        }
    }

    onMessage(message, sender, sendResponse) {
        if (message.channel == "ptk_popup2background_rattacker") {
            if (this["msg_" + message.type]) {
                return this["msg_" + message.type](message)
            }
            return Promise.resolve({ result: false })
        }

        if (message.channel == "ptk_content2rattacker") {

            if (message.type == 'xss_confirmed' && this.scanResult.host == (new URL(message.data.origin)).host) {
                this.checkConfirmedAttack(message.data)
            }

            if (message.type == 'start') {
                this.runBackroungScan(sender.tab.id, new URL(sender.origin).host)
                return Promise.resolve({ success: true, scanResult: JSON.parse(JSON.stringify(this.scanResult)) })
            }

            if (message.type == 'stop') {
                this.stopBackroungScan()
                let result = { items: [], count: 0 }
                let keys = Object.keys(this.scanResult.items)
                for (let i = 0; i < keys.length; i++) {
                    let item = this.scanResult.items[keys[i]]
                    for (let j = 0; j < item.attacks.length; j++) {
                        let info = item.attacks[j]

                        if (info.success) {
                            result.count++
                            result.items.push({
                                baseUrl: ptk_utils.escapeHtml(info.baseUrl),
                                proof: ptk_utils.escapeHtml(info.proof),
                                description: ptk_utils.escapeHtml(info.attack.description),
                                request: ptk_utils.escapeHtml(info.request),
                                headers: ptk_utils.escapeHtml(info.headers),
                                body: ptk_utils.escapeHtml(info.body)
                            })
                        }
                    }
                }
                return Promise.resolve({ scanResult: JSON.parse(JSON.stringify(result)) })
            }
        }
    }

    async msg_init(message) {
        await this.init()
        return Promise.resolve({ scanResult: JSON.parse(JSON.stringify(this.scanResult)) })
    }

    msg_reset(message) {
        this.reset()
        return Promise.resolve({ scanResult: JSON.parse(JSON.stringify(this.scanResult)) })
    }

    msg_run_scan(message) {
        this.reset()
        this.scanResult.scanId = ptk_utils.UUID()
        this.runAllAttacks(message.schema)
        return Promise.resolve({ success: true })
    }

    msg_run_bg_scan(message) {
        this.runBackroungScan(message.tabId, message.host)
        return Promise.resolve({ success: true, scanResult: JSON.parse(JSON.stringify(this.scanResult)) })
    }

    msg_stop_bg_scan(message) {
        this.stopBackroungScan()
        return Promise.resolve({ success: true, scanResult: JSON.parse(JSON.stringify(this.scanResult)) })
    }


    runBackroungScan(tabId, host) {
        this.reset()
        this.scanResult.scannedTabId = tabId
        this.scanResult.scanId = ptk_utils.UUID()
        this.scanResult.tabId = tabId
        this.scanResult.host = host
        this.scan()
        this.iast = new ptk_iast()
        this.iast.start(tabId)
        this.addListeners()
    }

    stopBackroungScan() {

        this.iast.stop(this.scanResult.tabId)
        this.scanResult.tabId = null
        this.scanResult.requestQueue.clear()
        ptk_storage.setItem(this.storageKey, this.scanResult)
        this.removeListeners()
    }

    addRequest(item) {
        let url = item.split('\n')[0]
        if (!this.scanResult.uniqueRequestQueue.has(url)) {
            this.scanResult.uniqueRequestQueue.enqueue(url)
            this.scanResult.requestQueue.enqueue(item)
        }
    }

    checkConfirmedAttack(data) {
        let keys = Object.keys(this.scanResult.items)
        for (let i = 0; i < keys.length; i++) {
            let item = this.scanResult.items[keys[i]]
            for (let j = 0; j < item.attacks.length; j++) {
                if (data.attackValue.ptk == item.attacks[j].attack.options.attackParamValue && !item.attacks[j].success) {
                    item.attacks[j].success = true
                    item.attacks[j].proof += btoa('Confirmed by code execution on ' + data.location + '. Attack parameter value is: ' + data.attackValue.ptk)
                    this.scanResult.stats.vulnsCount++
                }
            }
        }
    }

    async scan() {
        if (!this.scanResult.tabId) return
        let ptkRequest = new ptk_request({ "base": "" })

        while (this.scanResult.requestQueue.size()) {
            let item = this.scanResult.requestQueue.dequeue()
            let schema = ptkRequest.parseRawRequest({ request: item })
            this.runAllAttacks(schema)
        }

        let self = this
        setTimeout(function () { self.scan() }, 1000)
    }

    async runAllAttacks(schema) {
        let request = new ptk_request({ "base": "" })
        let attackId = ptk_utils.attackId()
        this.scanResult.items[attackId] = {}
        this.scanResult.items[attackId]['originalSchema'] = request.toString(schema)

        let originalRequest = await this.executeOriginal(schema, attackId)

        for (let key in this.attackModules) {
            let module = this.attackModules[key]
            for (let attackIndex in module.attacks) {
                let attack = module.attacks[attackIndex]
                if (attack.methods.includes(schema.request.method)) {

                    schema.request.asString = request.toString(schema)
                    let modified = module.prepareAttack(JSON.parse(JSON.stringify(schema)), JSON.parse(JSON.stringify(attack)), ptk_utils.attackParamId())

                    if (modified && modified.attack) {
                        let modifiedSchema = modified.schema
                        attack = modified.attack
                        if (["POST", "PUT", "DELETE", "PATCH"].includes(modifiedSchema.request.method)) {
                            modifiedSchema = this.modifyPostParams(modifiedSchema, attack.options)
                        }
                        let url = new URL(modifiedSchema.request.url)
                        if (url.search) {
                            modifiedSchema = this.modifyGetParams(modifiedSchema, attack.options)
                        }

                        modifiedSchema.asString = request.toString(modifiedSchema)

                        let item = await this.runAttack(modifiedSchema, attack)

                        let vulnRegex = attack.options.vulnRegex ? attack.options.vulnRegex : module.vulnRegex
                        module.validateAttack(item, vulnRegex, originalRequest)
                        if (item.success) this.scanResult.stats.vulnsCount++

                        this.scanResult.items[attackId]['attacks'].push(JSON.parse(JSON.stringify(item)))

                        browser.runtime.sendMessage({
                            channel: "ptk_background2popup_rattacker",
                            type: "attack completed",
                            info: item,
                            scanResult: JSON.parse(JSON.stringify(this.scanResult))
                        }).catch(e => ptk_logger.log(e, "Could not send a message", "info"))

                    }
                }
            }
        }
        if (!this.scanResult.requestQueue.size()) {
            ptk_storage.setItem(this.storageKey, this.scanResult)
            browser.runtime.sendMessage({
                channel: "ptk_background2popup_rattacker",
                type: "all attacks completed",
                scanResult: JSON.parse(JSON.stringify(this.scanResult))
            }).catch(e => ptk_logger.log(e, "Could not send a message", "info"))
        }
    }

    modifyPostParams(modifiedSchema, options) {
        let params = modifiedSchema.request.body.split('&')
        for (let i in params) {
            params[i] = options.position == 'before' ? params[i].replace('=', '=' + options.attackValue) : params[i] + options.attackValue
        }
        modifiedSchema.request.body = params.join('&')
        return modifiedSchema
    }

    modifyGetParams(modifiedSchema, options) {
        let url = new URL(modifiedSchema.request.url)
        for (const [key, value] of url.searchParams) {
            let v = options.position === 'before' ? options.attackValue + value : value + options.attackValue
            url.searchParams.set(key, v)
        }
        modifiedSchema.request.url = url.toString()
        return modifiedSchema
    }

    async executeOriginal(schema, attackId) {

        this.scanResult.items[attackId]['originalUrl'] = schema.request.url.href
        this.scanResult.items[attackId]['attacks'] = []

        let request = new ptk_request({ "base": "" })
        schema.request.followRedirect = true
        let origResult = await request.sendRequest(schema)

        this.scanResult.items[attackId]['originalResponseStatus'] = origResult.status
        this.scanResult.items[attackId]['originalResponseBody'] = origResult.body
        this.scanResult.items[attackId]['originalResponseHeaders'] = origResult.headers
        console.log(this.scanResult.items[attackId])
        return Promise.resolve({ status: origResult.status, body: origResult.body, headers: origResult.headers })
    }

    async runAttack(schema, attack) {
        let request = new ptk_request({ "base": "" })
        schema.request.followRedirect = true
        let item = {
            attack: attack,
            request: btoa(request.toString(schema)),
            baseUrl: schema.request.url,
            body: "",
            headers: "",
            failed: false
        }

        try {
            this.scanResult.stats.attacksCount++
            const result = await request.sendRequest(schema)
            let body = result.body
            item.body = body ? btoa(body) : ""
            item.headers = btoa(result.headers)
            item.responseStatus = result.responseStatus
            item.statusText = result.statusText
            item.responseStatusText = result.responseStatusText
            item.redirected = result.redirected
            return item
        } catch (error) {
            ptk_logger.log(error, "Could not run an attack", "info")
            item.failed = true
            return item
        }
    }

}

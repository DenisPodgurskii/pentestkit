/* Author: Denis Podgurskii */
import { ptk_utils, ptk_storage } from "./utils.js"

export class ptk_request {

    constructor(settings) {
        this.storageKey = 'ptk_rbuilder'
        this.storage = {}
        this.init()
    }

    async init(){
        this.trackingRequest = new Map()
        this.originalHeaders = null
        this.recording = { recordingRequests: [] }
        this.savedRequests = {}
        this.storage = await ptk_storage.getItem(this.storageKey)
    }

    async clear(index) {
        this.init()
        if (index)
            delete this.savedRequests[index]
        else
            this.savedRequests = {}

        this.storage = this.savedRequests
        await ptk_storage.setItem(this.storageKey, this.storage)
    }

    findLastIndex(obj, requestId) {
        let l = obj.length
        while (l--) {
            if (obj[l].requestId == requestId) return l
        }
        return -1
    }

    /* Listeners */

    addListeners() {

        this.onBeforeRequest = this.onBeforeRequest.bind(this)
        browser.webRequest.onBeforeRequest.addListener(
            this.onBeforeRequest,
            { urls: ["<all_urls>"], types: ptk_utils.requestFilters },
            [/*"blocking",*/ "requestBody"].concat(ptk_utils.extraInfoSpec)
        )

        this.onBeforeSendHeaders = this.onBeforeSendHeaders.bind(this)
        browser.webRequest.onBeforeSendHeaders.addListener(
            this.onBeforeSendHeaders,
            { urls: ["<all_urls>"], types: ptk_utils.filterType },
            [/*"blocking",*/ "requestHeaders"].concat(ptk_utils.extraInfoSpec)
        )

        this.onHeadersReceived = this.onHeadersReceived.bind(this);
        browser.webRequest.onHeadersReceived.addListener(
            this.onHeadersReceived,
            { urls: ["<all_urls>"], types: ptk_utils.filterType },
            [/*"blocking",*/ "responseHeaders"].concat(ptk_utils.extraInfoSpec)
        )
    }

    removeListeners() {
        browser.webRequest.onBeforeSendHeaders.removeListener(this.onBeforeSendHeaders)
        browser.webRequest.onBeforeRequest.removeListener(this.onBeforeRequest)
        browser.webRequest.onHeadersReceived.removeListener(this.onHeadersReceived)
    }

    onBeforeRequest(request) {
        if (this.requestFormId) {
            let item = {
                requestId: request.requestId, type: "main_frame", request: request, requestHeaders: request.requestHeaders,
                response: {}
            }
            this.recording.recordingRequests[this.requestFormId] = item
        }
    }

    onBeforeSendHeaders(request) {
        if (this.originalHeaders) {
            this.trackingRequest.set(request.requestId, {})
            request.requestHeaders = this.originalHeaders
            this.originalHeaders = null
        }

        let cacheControl = request.requestHeaders.find(obj => { return obj.name.toLowerCase() == "cache-control" });
        if (!cacheControl) {
            request.requestHeaders.push({
                "name": "Cache-Control",
                "value": "no-cache"
            })
        }

        if (this.requestFormId) {
            this.recording.recordingRequests[this.requestFormId].requestHeaders = request.requestHeaders
        }

        return { requestHeaders: request.requestHeaders }
    }


    onHeadersReceived(response) {
        if (this.trackingRequest.has(response.requestId)) {
            this.trackingRequest.get(response.requestId).statusLine = response.statusLine
            this.trackingRequest.get(response.requestId).headers = response.responseHeaders
        }
        return { responseHeaders: response.responseHeaders }
    }

    onCompleted(pentestkitRequest) {
        if (this.requestFormId) {
            let item = this.recording.recordingRequests[this.requestFormId]
            item.responseHeaders = pentestkitRequest.headers
            item.response.body = pentestkitRequest.body
            item.response.statusLine = pentestkitRequest.statusLine
        }
    }

    addMessageListeners() {
        this.onMessage = this.onMessage.bind(this)
        browser.runtime.onMessage.addListener(this.onMessage)
    }

    onMessage(message, sender, sendResponse) {
        if (message.channel == "ptk_popup2background_request") {
            if (this["msg_" + message.type]) {
                return this["msg_" + message.type](message)
            }
            return Promise.resolve({ result: false })
        }
    }

    async msg_init(message) {
        this.storage = await ptk_storage.getItem(this.storageKey)
        this.savedRequests = this.storage ? this.storage : {}
        return Promise.resolve(JSON.parse(JSON.stringify(this.savedRequests)))
    }

    msg_clear(message) {
        this.clear(message.index)
        return Promise.resolve()
    }

    msg_reset_all(message) {
        this.clear()
        return Promise.resolve()
    }

    async msg_parse_request(message) {
        try{
            let schema = this.parseRawRequest(message.item)
            if (schema.request.url) {
                schema.request.asString = this.toString(schema)
    
                if (message.formId){
                    this.savedRequests[message.formId] = JSON.parse(JSON.stringify(schema))
                    await ptk_storage.setItem(this.storageKey, this.savedRequests)
                }
    
                return Promise.resolve(JSON.parse(JSON.stringify(schema)))
            } else {
                return Promise.resolve()
            }
        }catch(e){
            console.log(e)
        }

    }

    async msg_update_request(message) {
        let schema = this.updateRawRequest(message.item)
        schema.request.asString = this.toString(schema)

        if (message.formId){
            this.savedRequests[message.formId] = JSON.parse(JSON.stringify(schema))
            await ptk_storage.setItem(this.storageKey, this.savedRequests)
        }

        return Promise.resolve(JSON.parse(JSON.stringify(schema)))
    }

    async msg_delete_request(message) {
        delete this.savedRequests[message.formId]
        await ptk_storage.setItem(this.storageKey, this.savedRequests)
        return Promise.resolve(JSON.parse(JSON.stringify(this.savedRequests)))
    }

    msg_send_request(message) {
        this.requestFormId = message.requestFormId
        return this.sendRequest(message.schema).then(function (response) {
            return Promise.resolve(response)
        })
    }

    msg_get_recording(message) {
        if (this.recording.recordingRequests) {
            return Promise.resolve(this.recording)
        }
    }

    /* End Listeners */

    msg_validate(message) {
        if (message.parameters) {
            browser.windows.create({
                url: browser.runtime.getURL("/ptk/browser/rbuilder.html?validateRequest=" + message.parameters),
                type: "popup",
                'width': 1200,
                'height': 700
            })
        }
    }

    updateRawRequest(requestObject) {

        if (!requestObject.request_url.startsWith(requestObject.request_protocol + "://"))
            requestObject.request_url = requestObject.request_protocol + "://" + requestObject.request_url.replace(/^https?:\/\//, '')

        if (requestObject.request.trim() == "") {
            requestObject.request = requestObject.request_method + " " + requestObject.request_url + " HTTP/1.1"
        } else {
            let requestData = requestObject.request.trim().split(/\r?\n/)
            requestData[0] = requestObject.request_method + " " + requestObject.request_url + " HTTP/1.1"
            requestObject.request = requestData.join('\n')
        }
        let schema = this.parseRawRequest(requestObject)

        return schema
    }

    parseRawRequest(requestObject) {
        let schema = this.requestSchema()
        let requestData = requestObject.request.trim().split(/\n\n/)
        let headerArray = requestData[0].split(/\r?\n/)

        let host = null
        if (headerArray.filter(x => x.includes('Host:')).length != 0) {
            let h = headerArray.filter(x => x.includes('Host:'))[0].split(":")
            h.shift()
            host = h.join(":").trim()
        }

        let requestString = headerArray.shift()
        if (requestString.toUpperCase().match(/(^GET|^POST|^HEAD|^PUT|^DELETE|^OPTIONS|^PATCH)/)) {
            let requestArray = requestString.split(' ')
            if (requestArray[1].startsWith('http') && requestArray[1].trim() != "http://" && requestArray[1].trim() != "https://") {
                schema.request.url = new URL(requestArray[1])

                //Add Host header if doesn't exist
                if (headerArray.filter(x => x.includes('Host:')).length == 0) {
                    headerArray.push('Host: ' + schema.request.url.host)
                } else {
                    headerArray[headerArray.findIndex(x => x.includes('Host:'))] = 'Host: ' + schema.request.url.host
                }
            } else {
                if (!host)
                    throw 'Host value not defined. Use an absolute URL or add "Host" header.'
                let baseUrl = requestObject.request_protocol + "://" + host
                schema.request.url = new URL(requestArray[1], baseUrl)

            }
            schema.request.method = requestArray[0].trim()
            schema.request.version = requestArray[2]
            schema.request.protocol = schema.request.url.protocol
            schema.request.host = schema.request.url.host
        }

        schema.request.headers = headerArray;
        if (requestData.length > 1 && schema.request.method != 'GET' && schema.request.method != 'HEAD') {
            schema.request.body = requestData[1]
        }
        return schema
    }

    sendRequest(schema) {
        this.addListeners()
        try {
            this.trackingRequest = new Map()
            this.originalHeaders = schema.request.headers.map(x => {
                let h = x.split(':')
                if (h.length > 2) return { name: h.shift(), value: h.join(":") }
                return { name: h[0], value: h[1] }
            })

            let rHeaders = new Headers(schema.request.headers.map(x => {
                let h = x.split(':')
                if (h.length > 2) return [h.shift(), h.join(":")]
                return h
            }))

            let params = {
                method: schema.request.method,
                mode: 'cors',
                redirect: schema.request.followRedirect ? "follow" : "manual",
                credentials: 'include', //same-origin
                cache: 'no-cache',
                headers: rHeaders
            }
            if (schema.request.body && !schema.request.method.toUpperCase().match(/(^GET|^HEAD)/)) {
                params.body = schema.request.body
            }

            let self = this
            let request = new Request(schema.request.url, params)
            return fetch(request).then(function (response) {
                if (!response.ok) {
                    console.log(response.status)
                }
                let pentestkitRequest = {}


                let responseStatus = response.status
                let responseStatusText = response.statusText
                let redirected = response.redirected

                return response.text().then(function (body) {

                    for (let value of self.trackingRequest.values()) {
                        pentestkitRequest = value
                    }
    
                    let headers = pentestkitRequest.statusLine + "\n"
                    pentestkitRequest.headers?.forEach(function (h, key) {
                        headers += (h.name != "" ? h.name + ": " : "") + h.value + "\r\n"
                    })

                    pentestkitRequest.body = body
                    self.onCompleted(pentestkitRequest)
                    self.removeListeners()
                    return { headers: headers, body: body, status: responseStatus, statusText: responseStatusText, redirected: redirected }
                })
            }).catch(e => {
                self.removeListeners()
                return Promise.reject(e)
            })
        } catch (e) {
            this.removeListeners()
            return Promise.reject(e)
        }
    }

    requestSchema() {
        return {
            request: {
                method: '',
                headers: [],
                cookie: [],
                body: '',
                version: '',
                url: null,
                params: null,
                host: null,
                protocol: null,
                followRedirect: true
            },
            response: {
                headers: [],
                content: ''
            }
        }
    }

    toString(schema) {
        let r = schema.request.method + ' ' + schema.request.url + ' ' + schema.request.version + '\n' + schema.request.headers.join('\n')
        if (schema.request.body) r += '\n\n' + schema.request.body
        return r
    }

}